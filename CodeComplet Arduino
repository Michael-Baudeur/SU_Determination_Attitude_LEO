#include <Arduino.h>
#include <Wire.h>
#include "DFRobot_BMM150.h"

//When using I2C communication, use the following program to construct an object by DFRobot_BMM150_I2C
/*!
 * @brief Constructor 
 * @param pWire I2C controller
 * @param I2C address
 *        i2c Address select, that CS and SDO pin select 1 or 0 indicates the high or low respectively. There are 4 combinations: 
 *          I2C_ADDRESS_1 0x10  (CS:0 SDO:0)
 *          I2C_ADDRESS_2 0x11  (CS:0 SDO:1)
 *          I2C_ADDRESS_3 0x12  (CS:1 SDO:0)
 *          I2C_ADDRESS_4 0x13  (CS:1 SDO:1) default i2c address
 */
DFRobot_BMM150_I2C bmm150(&Wire, I2C_ADDRESS_4);


// -------------------------------
// Panneaux solaires - Déclaration
// -------------------------------
const int nbPanneaux = 6;
const int pinsMesure[nbPanneaux] = {A0, A3, A6, A7, A4, A5};
float tensions[nbPanneaux] = {0};
float courants[nbPanneaux] = {0}; 

// -------------------------------
// Calibration BMM150
// -------------------------------



// -------------------------------
// Setup
// -------------------------------
void setup() {
  Serial.begin(115200);
  delay(1000);

  while(!Serial);
  while(bmm150.begin()){
    Serial.println("bmm150 init failed, Please try again!");
    delay(13000);
  } Serial.println("bmm150 init success!");

  /**!
   * Set sensor operation mode
   * opMode:
   *   BMM150_POWERMODE_NORMAL  // normal mode  Get geomagnetic data normally
   *   BMM150_POWERMODE_FORCED  // forced mode  Single measurement, the sensor restores to sleep mode when the measurement is done.
   *   BMM150_POWERMODE_SLEEP   // sleep mode   Users can visit all the registers, but can't measure geomagnetic data
   *   BMM150_POWERMODE_SUSPEND // suspend mode At the time the sensor cpu doesn't work and can't implement any operation.
   *                                            Users can only visit the content of the control register BMM150_REG_POWER_CONTROL
   */
  bmm150.setOperationMode(BMM150_POWERMODE_NORMAL);

  /**!
   * Set preset mode, make it easier for users to configure sensor to get geomagnetic data
   * presetMode:
   *   BMM150_PRESETMODE_LOWPOWER      // Low power mode, get a small number of data and take the mean value.
   *   BMM150_PRESETMODE_REGULAR       // Regular mode, get a number of data and take the mean value.
   *   BMM150_PRESETMODE_ENHANCED      // Enhanced mode, get a large number of data and take the mean value.
   *   BMM150_PRESETMODE_HIGHACCURACY  // High accuracy mode, get a huge number of data and take the mean value.
   */
  bmm150.setPresetMode(BMM150_PRESETMODE_HIGHACCURACY);

  /**!
   * Set the rate of obtaining geomagnetic data, the higher, the faster (without delay function)
   * rate:
   *   BMM150_DATA_RATE_02HZ
   *   BMM150_DATA_RATE_06HZ
   *   BMM150_DATA_RATE_08HZ
   *   BMM150_DATA_RATE_10HZ   (default rate)
   *   BMM150_DATA_RATE_15HZ
   *   BMM150_DATA_RATE_20HZ
   *   BMM150_DATA_RATE_25HZ
   *   BMM150_DATA_RATE_30HZ
   */
  bmm150.setRate(BMM150_DATA_RATE_10HZ);

  /**!
   * Enable the measurement at x-axis, y-axis and z-axis, default to be enabled, no config required, the geomagnetic data at x, y and z will be incorrect when disabled.
   * Refer to setMeasurementXYZ() function in the .h file if you want to configure more parameters.
   */
  bmm150.setMeasurementXYZ();
}


// -------------------------------
// Boucle principale
// -------------------------------
void loop() {
  // --- Lecture du magnétomètre ---
  sBmm150MagData_t magData = bmm150.getGeomagneticData();
  float heading = atan2(magData.x, magData.y);
  if (heading < 0) heading += 2 * PI;
  float headingDegrees = heading * 180 / M_PI;


  Serial.println("\n=== Données BMM150 ===");
  Serial.print("X: "); Serial.println(magData.x); 
  Serial.print("Y: "); Serial.println(magData.y); 
  Serial.print("Z: "); Serial.println(magData.z+30); 
  Serial.print("Direction (deg): "); 
  Serial.println(headingDegrees);
  float compassDegree = bmm150.getCompassDegree();


  // --- Lecture des panneaux solaires ---
 Serial.println("\n=== Mesure des panneaux solaires ===");

// 1) Lecture brute des courants
float courantsBruts[nbPanneaux];
float sommeBrute = 0;
float courantMax = 0;
int indexMax = -1;

for (int i = 0; i < nbPanneaux; i++) {
    int valeurBrute = analogRead(pinsMesure[i]);
    float tension = (valeurBrute * 3.3) / 4095.0; 
    float courant = tension / 0.1;  // shunt de 0.1 ohm

    courantsBruts[i] = courant;
    sommeBrute += courant;

    if (courant > courantMax) {
        courantMax = courant;
        indexMax = i;
    }
}

// 2) Application des règles spéciales
float courantsFinal[nbPanneaux];

// --- Cas 1 : un panneau dépasse 33 mA → il reste seul actif ---
if (courantMax >= 33.0) {
    for (int i = 0; i < nbPanneaux; i++) {
        courantsFinal[i] = (i == indexMax) ? 33.0 : 0.0;
    }
}

// --- Cas 2 : somme totale > 33 mA → normalisation globale ---
else if (sommeBrute > 33.0) {
    float ratio = 33.0 / sommeBrute;
    for (int i = 0; i < nbPanneaux; i++) {
        courantsFinal[i] = courantsBruts[i] * ratio;
    }
}

// --- Cas 3 : tout est normal ---
else {
    for (int i = 0; i < nbPanneaux; i++) {
        courantsFinal[i] = courantsBruts[i];
    }
}

// 3) Affichage
for (int i = 0; i < nbPanneaux; i++) {
    Serial.print("Panneau ");
    Serial.print(i + 1);
    Serial.print(" (pin ");
    Serial.print(pinsMesure[i]);
    Serial.print(") : ");
    Serial.print(courantsFinal[i], 2);
    Serial.println(" mA");
}



  Serial.println("-----------------------------");
  delay(1000);
}
